/* SPDX-License-Identifier: Apache-2.0 */
/* Copyright(c) 2022 Wind River Systems, Inc. */

package validating

import (
	"context"
	"fmt"
	"net/http"
	"strings"

	starlingxv1 "github.com/wind-river/cloud-platform-deployment-manager/pkg/apis/starlingx/v1"
	"sigs.k8s.io/controller-runtime/pkg/runtime/inject"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission/types"
)

// Webhook response reasons
const AllowedReason string = "allowed to be admitted"

func init() {
	webhookName := "validating-create-update-ptpinstance"
	if HandlerMap[webhookName] == nil {
		HandlerMap[webhookName] = []admission.Handler{}
	}
	HandlerMap[webhookName] = append(HandlerMap[webhookName], &PtpInstanceCreateUpdateHandler{})
}

// PtpInstanceCreateUpdateHandler handles PtpInstance
type PtpInstanceCreateUpdateHandler struct {
	// Decoder decodes objects
	Decoder types.Decoder
}

func (h *PtpInstanceCreateUpdateHandler) validateInstanceParameters(obj *starlingxv1.PtpInstance) (bool, string, error) {
	present := make(map[string]bool)
	for _, parameter := range obj.Spec.InstanceParameters {

		//TODO check if '=' exists, and only one, not the first character
		delim := "="
		if strings.Count(parameter, delim) != 1 || parameter[0:1] == delim {
			msg := fmt.Sprintf("Invalid parameter %s. Parameters must come in the form <parameterKey>=<parameterValue>.",
				parameter)
			return false, msg, nil
		}
		key := strings.TrimSpace(strings.Split(parameter, delim)[0])

		if _, ok := present[key]; ok {
			msg := fmt.Sprintf("duplicate parameter keys are not allowed for %s.",
				parameter)
			return false, msg, nil
		}
		present[key] = true

	}

	return true, AllowedReason, nil
}

// Validates an incoming resource update/create request.  The intent of this validation is to perform only the
// minimum amount of validation which should normally be done by the CRD validation schema, but until kubebuilder
// supports the necessary validation annotations we need to do this in a webhook.  All other validation is left
// to the system API and any errors generated by that API will be reported in the resource status and events.
func (h *PtpInstanceCreateUpdateHandler) validatingPtpInstanceFn(ctx context.Context, obj *starlingxv1.PtpInstance) (bool, string, error) {
	allowed, reason, err := h.validateInstanceParameters(obj)
	if !allowed || err != nil {
		return allowed, reason, err
	}

	return allowed, reason, err
}

var _ admission.Handler = &PtpInstanceCreateUpdateHandler{}

// Handle handles admission requests.
func (h *PtpInstanceCreateUpdateHandler) Handle(ctx context.Context, req types.Request) types.Response {
	obj := &starlingxv1.PtpInstance{}

	err := h.Decoder.Decode(req, obj)
	if err != nil {
		return admission.ErrorResponse(http.StatusBadRequest, err)
	}

	allowed, reason, err := h.validatingPtpInstanceFn(ctx, obj)
	if err != nil {
		return admission.ErrorResponse(http.StatusInternalServerError, err)
	}
	return admission.ValidationResponse(allowed, reason)
}

var _ inject.Decoder = &PtpInstanceCreateUpdateHandler{}

// InjectDecoder injects the decoder into the PlatformNetworkCreateUpdateHandler
func (h *PtpInstanceCreateUpdateHandler) InjectDecoder(d types.Decoder) error {
	h.Decoder = d
	return nil
}
